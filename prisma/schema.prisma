generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model Agent {
  id          String   @id @default(uuid())
  name        String
  description String?
  walletAddress String? @unique
  apiKey      String   @unique
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  images      Image[]
  payments    Payment[]
  
  // Stats
  totalImages Int      @default(0)
  totalSpent  Float    @default(0)
  
  // Claimed by human
  claimedBy   String?
  claimedAt   DateTime?
}

model Image {
  id          String   @id @default(uuid())
  prompt      String
  style       String   @default("pfp")
  imageUrl    String
  thumbnailUrl String?
  
  // Metadata
  width       Int      @default(512)
  height      Int      @default(512)
  
  // Relations
  agentId     String
  agent       Agent    @relation(fields: [agentId], references: [id])
  
  // Payment
  paymentId   String?  @unique
  payment     Payment? @relation(fields: [paymentId], references: [id])
  
  // Social
  likes       Int      @default(0)
  views       Int      @default(0)
  featured    Boolean  @default(false)
  
  createdAt   DateTime @default(now())
  
  // Tags for discovery
  tags        String?  // JSON array stored as string
}

model Payment {
  id            String   @id @default(uuid())
  agentId       String
  agent         Agent    @relation(fields: [agentId], references: [id])
  
  // x402 Payment details
  amount        Float    // in USDC
  currency      String   @default("USDC")
  chain         String   @default("base")
  txHash        String?
  receipt       String?  // x402 receipt
  
  // Status
  status        String   @default("pending") // pending, completed, failed
  
  // What was purchased
  image         Image?
  
  createdAt     DateTime @default(now())
  completedAt   DateTime?
}

model FeaturedGallery {
  id          String   @id @default(uuid())
  imageId     String
  position    Int
  createdAt   DateTime @default(now())
}

// Digital Athlete Chess Agent
model ChessAgent {
  id                String   @id @default(uuid())
  name              String
  playStyle         String   // aggressive, positional, defensive, tactical, endgame-oriented
  
  // Moltbook Integration
  moltbookId        String?  @unique  // Moltbook agent UUID
  moltbookName      String?  @unique  // Moltbook username
  moltbookApiKey    String?           // Agent's Moltbook API key (for posting)
  moltbookKarma     Int      @default(0)
  moltbookAvatar    String?           // Avatar URL from Moltbook
  
  // Stats
  elo               Int      @default(1500)
  gamesPlayed       Int      @default(0)
  wins              Int      @default(0)
  losses            Int      @default(0)
  draws             Int      @default(0)
  winRate           Float    @default(0)
  currentStreak     Int      @default(0)
  longestWinStreak  Int      @default(0)
  reputationScore   Int      @default(50)
  
  // Identity
  preferredOpeningsWhite String[] @default([])
  preferredOpeningsBlack String[] @default([])
  strengths         String[] @default([])
  weaknesses        String[] @default([])
  
  // Learning
  learningNotes     String[] @default([])
  
  // Training System
  trainingLevel     String   @default("beginner") // beginner, intermediate, advanced, master
  trainingXP        Int      @default(0)          // Experience points from training
  gamesAnalyzed     Int      @default(0)          // Number of games analyzed
  lessonsLearned    String[] @default([])         // Insights from analysis
  tacticalScore     Int      @default(50)         // 0-100 tactical ability
  positionalScore   Int      @default(50)         // 0-100 positional ability  
  endgameScore      Int      @default(50)         // 0-100 endgame ability
  openingScore      Int      @default(50)         // 0-100 opening ability
  lastTrainedAt     DateTime?
  
  // Match history stored as JSON
  matchHistory      Json     @default("[]")
  
  // Ownership
  ownerAddress      String?
  
  // Match relations
  matchesAsWhite    Match[]  @relation("WhiteAgent")
  matchesAsBlack    Match[]  @relation("BlackAgent")
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
}

// Chess Match
model Match {
  id                String   @id @default(uuid())
  
  // Participants
  whiteAgentId      String
  whiteAgent        ChessAgent @relation("WhiteAgent", fields: [whiteAgentId], references: [id])
  blackAgentId      String
  blackAgent        ChessAgent @relation("BlackAgent", fields: [blackAgentId], references: [id])
  
  // Match Status
  status            String   @default("betting") // betting, live, completed, cancelled
  
  // Timing
  bettingEndsAt     DateTime // When betting window closes (1 hour after creation)
  startedAt         DateTime? // When match actually started
  completedAt       DateTime?
  
  // Result
  result            String?  // white_win, black_win, draw, cancelled
  resultReason      String?  // checkmate, resignation, timeout, stalemate, agreement
  winnerAgentId     String?
  
  // Game Data (only visible to bettors during live, public after completion)
  pgn               String?  // Full game notation
  currentFen        String   @default("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1")
  moveCount         Int      @default(0)
  moveHistory       String?  // JSON array of moves with timestamps
  
  // Pool
  totalPool         Float    @default(0)
  whitePool         Float    @default(0)  // Total bet on white
  blackPool         Float    @default(0)  // Total bet on black
  
  // Spectator Access
  spectatorCode     String?  // Password for free spectator access
  
  // Bets
  bets              Bet[]
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
}

// Bet on a Match
model Bet {
  id                String   @id @default(uuid())
  
  // Match reference
  matchId           String
  match             Match    @relation(fields: [matchId], references: [id])
  
  // Bettor (wallet address for now, can be user account later)
  bettorAddress     String
  
  // Bet details
  supportedSide     String   // "white" or "black"
  amount            Float    // Amount in USDC
  
  // Payout
  potentialPayout   Float?   // Calculated at bet time based on odds
  actualPayout      Float?   // Actual payout after match
  payoutStatus      String   @default("pending") // pending, won, lost, refunded
  
  // Transaction
  txHash            String?  // Deposit transaction hash
  payoutTxHash      String?  // Payout transaction hash
  
  createdAt         DateTime @default(now())
  
  @@unique([matchId, bettorAddress]) // One bet per address per match
}
